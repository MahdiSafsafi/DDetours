#summary One-sentence summary of this page.

= Introduction =

*The InstDecode Library* is a library allowing to you to decode intel instruction . It support (x86-x64) architecture .

The library has too function : *DecodeInstruction* and *GetMaxInstLen functions *.
 


== DecodeInstruction function :==

{{{
function DecodeInstruction(const Addr: Pointer; Inst: PInstruction; CPUX: TCPUX): ShortInt;
}}}
This function is the main function for this library .It can decode instructions , and retrieve information about the instruction that was decoded such as :
   * Instruction size .
   * OpCode value .
   * Number of operands.
   * Displacement value .
   * Immediate value .
   * ...

===Params:=== 
*Addr :* Pointer to the instruction .

*Inst :* Pointer to TInstruction structure.It contains the information returned by the *DecodeInstruction function* .

*CPUX :* Specify the architecture : *CPUX86* for x86 and *CPUX64* for x64 architecture .  

===TInstruction Structure :===
{{{
type
  PPrefixes = ^TPrefixes;

  TPrefixes = packed record
    Count: Byte; // Numbers of prefixes used by the instruction .
    case Integer of
      0: (Pref1, Pref2, Pref3, Pref4: Byte);
      1: (Prefixes: Array [0 .. 4 - 1] of Byte);
      2: (Value: DWORD);
  end;

  PModRM = ^TModRM;

  TModRM = record
    Used: Boolean; { True if instruction use ModRM . }
    Value: Byte; { Value of ModRM . }
    rMod: Byte; { Mod field value . }
    rReg: Byte; { Reg field value . }
    rRM: Byte; { RM field value . }
    OpExt: Boolean; { True if  ModRM store OpCode extension . }
  end;

  PSIB = ^TSIB;

  TSIB = packed record
    Used: Boolean;
    Scale: Byte;
    Index: Byte;
    Base: Byte;
    Value: Byte;
  end;

  PDisplacement = ^TDisplacement;

  TDisplacement = packed record
    Used: Boolean; { True if instruction use Displacement . }
    i32: Boolean; { True if size of Displacement = 32 bit ; otherwise False : size of Displacement = 8 bit }
    Value: Integer; { Displacement value . }
    Relative: Boolean; { True if Displacement is Relative => only for x64 bit . }
  end;

  PImmediate = ^TImmediate;

  TImmediate = packed record
    Used: Boolean; { True if instruction use Immediate . }
    SizeOfImmediate: Byte; { Size Of Immediate Value [1,2,4,8] bytes . }
    Value: Int64; { Value of Immediate . }
  end;

  PJumpCall = ^TJumpCall;

  TJumpCall = packed record
    Used: Boolean; { True if instruction is JUMP or CALL . }
    JumpUsed: Boolean; { True if instruction is JUMP . }
    CallUsed: Boolean; { True if instruction is CALL . }
    Relative: Boolean; { True if instruction use Relative offset . }
    IndirectDispOnly: Boolean; { True if JUMP/CALL Indirect Disp only => JMP [123456] }
    IndirectReg: Boolean; { True if JUMP/CALL Indirect  => JMP [EAX]; JMP [EAX + 123456] }
    OffsetSize: Byte; { Size of Offset . }
    Offset: Integer; { Offset value . }
    Address: UInt64; { Destination address . }
  end;

  TOpCodeParams = packed record
    nOp: Byte; // Numbers of operands .
    Op1: DWORD; // Operand 1 flags .
    Op2: DWORD; // Operand 2 flags .
    Op3: DWORD; // Operand 3 flags .
    Op4: DWORD; // Operand 4 flags .
  end;

  PInstruction = ^TInstruction;

  TInstruction = packed record
    Address: Pointer; { Current Address }
    Mod16: Boolean; { True if size of operand =  16 bit }
    Mod64: Boolean; { True if size of operand =  64 bit }
    Prefixes: TPrefixes; { Prefixes }
    OpCode: Word; { OpCode }
    nOpCode: Byte; { Numbers of OpCode ==> Max = 3 }
    SOpCode: Byte; { Secondary OpCode Value }
    SOpUsed: Boolean; { True if Secondary OpCode Used . }
    Params: TOpCodeParams; { Operand Params }
    ModRM: TModRM; { ModRM }
    SIB: TSIB; { SIB }
    Displacement: TDisplacement; { Displacement }
    Immediate: TImmediate; { Immediate }
    JumpCall: TJumpCall; { JumpCall }
    InstSize: ShortInt; { Instruction Size }
    NextInst: Pointer; { Pointer to the next instruction . }
  end;
}}}
 
=== Example :===
{{{
function Foo: Integer;
asm
  MOV EAX,8
  ADD EAX,2
end;

var
  Inst: TInstruction;
begin
  Foo;
  FillChar(Inst, SizeOf(TInstruction), #0);
  DecodeInstruction(@Foo, @Inst, CPUX32); // Instruction = MOV EAX,8 .
  ShowMessage(IntToStr(Inst.InstSize)); // InstSize = 5 .
end;
}}}

== GetMaxInstLen function :==
{{{
function GetMaxInstLen(CPUX: TCPUX): ShortInt;
}}}
This function return the maximum instruction length depending on the architecture specified by the CPUX parameter .