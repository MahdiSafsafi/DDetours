= Delphi Detours Library version 2 =

= Major changes=

  # Introducing new hooking model architecture.
  # Many BugFix
  # Adding multi hook support.
  # Detecting Hook.
  # Introducing instructions maping feature.
  # Adding COM object hooking support.
  # Generate better opcodes.
  # New InstDecode Library

== New hooking model architecture==

The new version introduce a new hooking model architecture , allowing support for multi hooks as well as single hook.

Whatever , your hook is instaled from you application process or via (dll,..),DDL will mange your hook to run without problems with others hooks.

https://dl.dropboxusercontent.com/u/99625333/imgs/DDL.png

With this new architecture , DDL guaranties:

  * New hooks will never override valid adjacent routines.
  * A single TrampoLine function for all installed hooks.
  * The TrampoLine is as much as possible small in size.  
  * Removing a hook does not affect others hooks.

== BugFix==

  * Fix instructions decoding related bugs.
  * Fix Memory allocation bug.
  * Fix Branch calculation.
  * Fix VirtualFree bug.
  * Fix hooking functions that have many jmp before entering main implementation.

== Multi Hooking==
  * A target function can be hooked by *several hooks.*
  * Calling TrampoLine will result in calling next installed hook.
You can think like functions overriding inside a class.

== Detecting Hook==
In this version , i introduced new functions to detect if a function is being hooked:
{{{
{Return the number of installed hooks on a function}
function GetNHook(const TargetProc: Pointer): ShortInt;

{Check if the function is hooked}
function IsHooked(const TargetProc: Pointer): Boolean;
}}}
  
==Instructions Maping==
DDL will try to correct relative offset when it's possible, however when the new offset size is greater than 32-bits (especially on x64) it will try to map the instruction to an alternative instruction or even generate an opcodes that will acts as the original.

https://dl.dropboxusercontent.com/u/99625333/imgs/Maping.png

This process is used only when DDL detect that excuting TrampoLine routine may fail.

==COM object/Interface hooking support==
The new version provide support for hooking methods declared inside interface.
The hook will be installed at the top of function code implementation.
{{{
const
  IID_MyInterface = '{569B8AF2-0C44-4AE4-827D-56FE49367F24}';

type
  IMyInterface = Interface(IInterface)
    [IID_MyInterface]
    procedure ShowMsg(const Msg: string);
  end;

  TMyObject = class(TInterfacedObject, IMyInterface)
    procedure ShowMsg(const Msg: string);
  end;

var 
	FMyInterface: IMyInterface; 
	
{ TMyObject }

procedure TMyObject.ShowMsg(const Msg: string);
begin
  // Your hook will be installed here !
  ShowMessage(Msg);
end;

procedure MyInterface_ShowMsg_Hook(const Self; const Msg: string);
begin
  Trampo_MyInterface_ShowMsg(Self, 'Message Hooked!');
end;

@Trampo_MyInterface_ShowMsg := InterceptCreate(FMyInterface, 3, @MyInterface_ShowMsg_Hook);

}}}
{{{
{Simple example showing how to hook COM object }
var
  DesktopShellFolder: IShellFolder;
  TrampoParseDisplayName: function(const Self; hwndOwner: HWND; pbcReserved: Pointer; lpszDisplayName: POLESTR; out pchEaten: ULONG; out ppidl: PItemIDList;
    var dwAttributes: ULONG): HResult; stdcall;

function GetDesktopShellFolder: IShellFolder;
begin
  OleCheck(SHGetDesktopFolder(Result));
end;

procedure TMain.Button1Click(Sender: TObject);
var
  ItemIdList: PItemIDList;
  Folder: IShellFolder;
  FileName: string;
  pchEaten: ULONG;
  Attr: Cardinal;
begin
  Attr := 0;
  pchEaten := 0;
  FileName := 'C:\';
  DesktopShellFolder.ParseDisplayName(0, nil, PChar(FileName), pchEaten, ItemIdList, Attr);
end;

function ParseDisplayName_Hook(const Self; hwndOwner: HWND; pbcReserved: Pointer; lpszDisplayName: POLESTR; out pchEaten: ULONG; out ppidl: PItemIDList;
  var dwAttributes: ULONG): HResult; stdcall;
begin
  {
   Using DDL can help you understand how functions work !
  eg:
  ParseDisplayName is a callback function , and it get called 3 time !
  }
  Main.LogMem.Lines.Add('----------------------------------');
  Main.LogMem.Lines.Add(Format('lpszDisplayName = %s', [lpszDisplayName]));
  Main.LogMem.Lines.Add(Format('ppidl = %p', [ppidl]));
  Result := TrampoParseDisplayName(Self, hwndOwner, pbcReserved, lpszDisplayName, pchEaten, ppidl, dwAttributes);
end;

initialization

DesktopShellFolder := GetDesktopShellFolder;
@TrampoParseDisplayName := InterceptCreate(DesktopShellFolder, 3, @ParseDisplayName_Hook);
}}}

==Generate better opcodes==
In this new version , DDL generate better opcodes for branch and for nop instructions.
For branch instructions:
It calculate the offset first then it decides what's the perfect branch/jump to use :
  # JMP Rel8
  # JMP Rel16 (x32 only)
  # JMP Rel32
  # JMP Mem32 (x32 only)
  # JMP Mem64 (x64 only)
  # JMP Rip Zero (x64 only)

Using better jmp will result in a small trampoline size.
For Nop:
DDL use Multi Bytes Nop instructions instead of the traditional (Nop N) instructions.
The use of MultiBytesNop is determined by your CPU.
if your CPU support MultiBytesNop ,DDL will use it when it's possible,Otherwise
it use traditional Nop instructions.

==InstDecode Library==
The new InstDecode Library includes the following updates :
  * Updated opcodes map .
  * Adding support to three byte opcodes escape Table.
  * Adding support to vex decoding (vex three & two byte).
  * Adding support to groups opcodes instructions.
  * Adding support to decode invalid opcode .
  * Adding support to 16-bits ModRm .
  * Adding support to handling errors.
  * Adding support for mandatory prefixes.
  * Improve Decoding Process .=> Very faster than the old one !
  * Reduce memory usage .
  * Removing inused fields.
  * Better support for REX prefix.
  * Reduce OpCodesTable data size (the old : 8670 bytes => the new one : 1020 bytes !)
  * BugFix : FPU instructions length.
  * BugFix : Invalid instructions on x64/x32.
  * BugFix : Calculating branch destination.
  * BugFix : Instructions that use two immediat .
  * BugFix : Invalid instructions .
  * BugFix : Invalid instructions for some mandatory prefixes.
  * Many Others Bug Fix.